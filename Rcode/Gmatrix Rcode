#Downloads and unzips the G-matrix Data repository from GitHub
download.file("https://github.com/jprice96/G-matrix-Database/archive/master.zip", destfile="cov_matrices.zip")
unzip("cov_matrices.zip")

#Resets working directory from My Documents to downloaded Cov_matrices folder
setwd("G-matrix-Database-master/Cov_matrices")

#This creates a list of all of the files in the directory
data.files = dir(pattern="*csv")

#This is the number of files/matrices we have
num.of.files = length(data.files)

#This creates a blank list
input.data = list()

#This creates a list of file names minus the .csv
file.names = list()
for(i in 1:num.of.files){
  file.names[i] = gsub(".csv", "", data.files[i])
}
col.names = list("trait", "trait.mean", "heritability")

#This is a loop which goes through the files and converts the data
for(i in 1:num.of.files){
  input.data[[i]] = read.csv(data.files[i], header=FALSE)
  colnames(input.data[[i]]) = col.names
}

#This names all of the files by their author, year and pop
names(input.data) = file.names


#Sorting by sub-pop
populations = list()
for (i in 1:length(file.names)){
  populations[i] = strsplit(as.character(file.names[i]), split="_")
}

data.groups = data.frame()
data.groups[1,1] = 0
n = 1
for (i in 1:length(populations)){
  new.pop = TRUE
  for (j in 1:length(data.groups[1,])){
    if (data.groups[1,j] == populations[[i]][1]){
      new.pop = FALSE
    }
  }
  if (new.pop == TRUE){
    pop.name = objects(input.data, pattern=as.character(populations[[i]][1]));
    data.groups[1,n] = populations[[i]][1];
    data.groups[2:(length(pop.name)+1),n] = pop.name;
    n = n + 1
  }
}


# Extracting mixed (co)variance - correlation matrices
mix.matrices = list()
for (i in 1:num.of.files){
  mix.matrices[[i]] = (input.data[[i]][,4:((4+nrow(input.data[[i]][1]))-1)])
}
names(mix.matrices) = file.names

#Extracting (co)variance matrices
G.matrices = list()
G.matrices[[1]] = 0
G.matrices[[2]] = 0
k =1
for (i in 1:num.of.files){
  if(mix.matrices[[i]][1,1]!="NULL"){
    G.matrices[[k]] = matrix(nrow = length(mix.matrices[[i]][1,]), ncol=length(mix.matrices[[i]][1,]))
    lth = length(mix.matrices[[i]][1,])
    for (j in 1:lth){
      G.matrices[[k]][j:lth,j] = mix.matrices[[i]][j:lth,j]
      G.matrices[[k]][j,j:lth] = mix.matrices[[i]][j:lth,j]
    }
    k = k+1
  }
}

#Extracting correlation matrices
C.matrices = list()
C.matrices[[1]] = 0
C.matrices[[2]] = 0
for (i in 1:num.of.files){
  C.matrices[[i]] = matrix(nrow = length(mix.matrices[[i]][1,]), ncol=length(mix.matrices[[i]][1,]))
  lth = length(mix.matrices[[i]][1,])
  for (j in 1:(lth-1)){
    j_ = j+1
    C.matrices[[i]][j_:lth,j] = as.numeric(as.vector(unlist(mix.matrices[[i]][j,j_:lth], use.names=FALSE)))
    C.matrices[[i]][j,j_:lth] = as.numeric(as.vector(unlist(mix.matrices[[i]][j,j_:lth], use.names=FALSE)))
    C.matrices[[i]][j,j] = 1
  }
  C.matrices[[i]][lth,lth] = 1
}


#Check if study has G-matrix
has.Gmatrix = list()
for(i in 1:num.of.files){
  if(mix.matrices[[i]][1,1]=="NULL"){
    has.Gmatrix[i] = FALSE
  }
  if(mix.matrices[[i]][1,1]!="NULL"){
    has.Gmatrix[i] = TRUE
  }
}

G.mat.idxs = list()
k=1
for(i in 1:num.of.files){
  if(has.Gmatrix[i] == TRUE){
    G.mat.idxs[k] = i;
    k=k+1
  }
}

xstd.mat = list()
xstd.mat[[1]] = 0
xstd.mat[[2]] = 0
xstd.names = list()
k=1
for(i in 1:length(G.mat.idxs)){
  idx = G.mat.idxs[i]
  idx = idx[[1]]
  if(input.data[[idx]][2,2]!="NULL"){
    xstd.mat[[k]] = matrix(c(as.matrix(G.matrices[[i]]), input.data[[idx]][,2]), nrow = length(input.data[[idx]][,2]));
    xstd.names[k] = names(input.data[idx]);
    k=k+1
  }
}


#Mean standardize
X.matrices = list()
X.matrices[[1]] = 0
X.matrices[[2]] = 0
for(i in 1:length(xstd.mat)){
  mat.dim = length(xstd.mat[[i]][,1])
  Gmat = xstd.mat[[i]][1:mat.dim, 1:mat.dim]
  means = xstd.mat[[i]][,(mat.dim+1)]
  Mmat = means%*% t(means)
  X.matrices[[i]] = Gmat / Mmat
}
names(X.matrices) = xstd.names




#Comparison of Gmax contribution to variance (CORR matrices)

anc.gmax = list()
nov.gmax = list()
has.NOV = grep("NOV", data.groups[3,])
for(i in 1:length(has.NOV)){
  idx = has.NOV[i]
  pops = data.groups[2:3,idx]
  anc.idx = grep(pops[1], file.names)
  nov.idx = grep(pops[2], file.names)
  anc.mat = C.matrices[[anc.idx]]
  
  anc.egn = eigen(anc.mat)
  anc.val = anc.egn$values
  anc.val = anc.val/length(anc.val)
  anc.gmax[i] = anc.val[1]
  
  nov.mat = C.matrices[[nov.idx]]
  nov.egn = eigen(nov.mat)
  nov.val = nov.egn$values
  nov.val = nov.val/length(nov.val)
  nov.gmax[i] = nov.val[1]
}

ANC = 1
ANC = rep(ANC, times=length(anc.gmax))
ID = c(1:length(anc.gmax))
anc.gmax = as.data.frame(t(as.data.frame(anc.gmax)), row.names=c(1:length(anc.gmax)))
anc.gmax = data.frame(gmax=anc.gmax, env=ANC, ID=ID)

NOV = 2
NOV = rep(NOV, times=length(nov.gmax))
ID = c(1:length(nov.gmax))
nov.gmax = as.data.frame(t(as.data.frame(nov.gmax)), row.names=c(1:length(nov.gmax)))
nov.gmax = data.frame(gmax=nov.gmax, enc=NOV, ID=ID)

comb.gmax = data.frame(gmax=c(anc.gmax[,1], nov.gmax[,1]), env=c(anc.gmax[,2], nov.gmax[,2]), ID=c(anc.gmax[,3], nov.gmax[,3]))

#y.lim = c(0.2,1.0)
stripchart(comb.gmax$gmax~comb.gmax$env, method="jitter", jitter=0.0075, vertical=TRUE, main="Correlation matrices", xlab="Environment (ANC , NOV)", ylab="Gmax / n of traits"
           #, ylim=y.lim
)
IDs = factor(comb.gmax$ID)
IDs = levels(IDs)
for(i in 1:length(IDs)){
  variance=list(comb.gmax$gmax[i],comb.gmax$gmax[i+length(IDs)])
  variance = as.numeric(variance)
  env=list(1,2)
  env=as.numeric(env)
  abline(lm(variance~env))
}



#Comparison of Gmax contribution to variance FOR XSTD MATRICES

anc.gmax = list()
nov.gmax = list()
has.NOV = grep("NOV", xstd.names)
for(i in 1:length(has.NOV)){
  idx = has.NOV[i]
  pops = xstd.names[(idx-1):idx]
  anc.idx = grep(pops[1], xstd.names)
  nov.idx = grep(pops[2], xstd.names)
  
  anc.mat = X.matrices[[anc.idx]]
  anc.egn = eigen(anc.mat)
  anc.val = anc.egn$values
  anc.gmax[i] = anc.val[1]#/sum(anc.val)
  
  nov.mat = X.matrices[[nov.idx]]
  nov.egn = eigen(nov.mat)
  nov.val = nov.egn$values
  nov.gmax[i] = nov.val[1]#/sum(nov.val)
}

ANC = 1
ANC = rep(ANC, times=length(anc.gmax))
ID = c(1:length(anc.gmax))
anc.gmax = as.data.frame(t(as.data.frame(anc.gmax)), row.names=c(1:length(anc.gmax)))
anc.gmax = data.frame(gmax=anc.gmax, env=ANC, ID=ID)

NOV = 2
NOV = rep(NOV, times=length(nov.gmax))
ID = c(1:length(nov.gmax))
nov.gmax = as.data.frame(t(as.data.frame(nov.gmax)), row.names=c(1:length(nov.gmax)))
nov.gmax = data.frame(gmax=nov.gmax, enc=NOV, ID=ID)

comb.gmax = data.frame(gmax=c(anc.gmax[,1], nov.gmax[,1]), env=c(anc.gmax[,2], nov.gmax[,2]), ID=c(anc.gmax[,3], nov.gmax[,3]))

#y.lim = c(0,0.3)
stripchart(comb.gmax$gmax~comb.gmax$env, method="jitter", jitter=0.0075, vertical=TRUE, main="Mean Std. matrices", xlab="Environment (ANC , NOV)", ylab="Gmax"
           #, ylim=y.lim
)
IDs = factor(comb.gmax$ID)
IDs = levels(IDs)
for(i in 1:length(IDs)){
  variance=list(comb.gmax$gmax[i],comb.gmax$gmax[i+length(IDs)])
  variance = as.numeric(variance)
  env=list(1,2)
  env=as.numeric(env)
  abline(lm(variance~env))
}


#Comparison of size of G (XSTD matrices only)

anc.va = list()
nov.va = list()
has.NOV = grep("NOV", xstd.names)
for(i in 1:length(has.NOV)){
  idx = has.NOV[i]
  pops = xstd.names[(idx-1):idx]
  anc.idx = grep(pops[1], xstd.names)
  nov.idx = grep(pops[2], xstd.names)
  
  anc.mat = X.matrices[[anc.idx]]
  anc.egn = eigen(anc.mat)
  anc.val = anc.egn$values
  anc.va[i] = sum(anc.val)
  
  nov.mat = X.matrices[[nov.idx]]
  nov.egn = eigen(nov.mat)
  nov.val = nov.egn$values
  nov.va[i] = sum(nov.val)
}

ANC = 1
ANC = rep(ANC, times=length(anc.va))
ID = c(1:length(anc.va))
anc.va = as.data.frame(t(as.data.frame(anc.va)), row.names=c(1:length(anc.va)))
anc.va = data.frame(Va=anc.va, env=ANC, ID=ID)

NOV = 2
NOV = rep(NOV, times=length(nov.va))
ID = c(1:length(nov.va))
nov.va = as.data.frame(t(as.data.frame(nov.va)), row.names=c(1:length(nov.va)))
nov.va = data.frame(Va=nov.va, enc=NOV, ID=ID)


comb.va = data.frame(Va=c(anc.va[,1], nov.va[,1]), env=c(anc.va[,2], nov.va[,2]), ID=c(anc.va[,3], nov.va[,3]))

#y.lim = c(0.2,1.0)
stripchart(comb.va$Va~comb.va$env, method="jitter", jitter=0.0075, vertical=TRUE, main="Size of G", xlab="Environment (ANC , NOV)", ylab="Total variance (size)"
           #, ylim=y.lim
)
IDs = factor(comb.va$ID)
IDs = levels(IDs)
for(i in 1:length(IDs)){
  variance=list(comb.va$Va[i],comb.va$Va[i+length(IDs)])
  variance = as.numeric(variance)
  env=list(1,2)
  env=as.numeric(env)
  abline(lm(variance~env))
}




#Distribution of variance across eigenvalues

anc.values = list()
anc.values[[1]] = 0
anc.values[[7]] = 0
nov.values = list()
nov.values[[1]] = 0
nov.values[[7]] = 0
has.NOV = grep("NOV", data.groups[3,])
for(i in 1:length(has.NOV)){
  idx = has.NOV[i]
  anc.mat = C.matrices[[(idx-1)]]
  nov.mat = C.matrices[[idx]]
  
  anc.egn = eigen(anc.mat)
  anc.val = anc.egn$values
  anc.val = anc.val/length(anc.val)
  
  nov.egn = eigen(nov.mat)
  nov.val = nov.egn$values
  nov.val = nov.val/length(nov.val)
  
  for(k in 1:length(anc.val)){
    anc.values[[k]][i] = anc.val[k]
    nov.values[[k]][i] = nov.val[k]
  }
}

anc.table = data.frame()
for(i in 1:length(anc.values)){
  anc.table[(1:length(anc.values[[i]])),i] = anc.values[[i]]
}
ANC = "ANC"
anc.table[(1:length(anc.table[,1])),(length(anc.table[1,])+1)] = rep(ANC, times=length(anc.table[,1]))

nov.table = data.frame()
for(i in 1:length(nov.values)){
  nov.table[(1:length(nov.values[[i]])),i] = nov.values[[i]]
}
NOV = "NOV"
nov.table[(1:length(nov.table[,1])),(length(nov.table[1,])+1)] = rep(NOV, times=length(nov.table[,1]))


colours = c(rep("grey20",2), rep("grey80",2))
x.axis.labels = c("E1", "E2", "E3", "E4", "E5", "E6", "E7")
x.axis.ticks = c(1.5, 3.5, 5.5, 7.5, 9.5, 11.5, 13.5)
boxplot(list(anc.values[[1]], nov.values[[1]],
             anc.values[[2]], nov.values[[2]],
             anc.values[[3]], nov.values[[3]],
             anc.values[[4]], nov.values[[4]],
             anc.values[[5]], nov.values[[5]],
             anc.values[[6]], nov.values[[6]],
             anc.values[[7]], nov.values[[7]]),
        col=colours, xlab="Amount of total variation contributed", ylab="Eigenvalues", main="Comparison of eigenvalue variance distribution between environments",
        frame.plot=FALSE, axes=FALSE)
axis(1, at=x.axis.ticks, labels=x.axis.labels)
axis(2)
legend(11, 0.7, legend=c("left=ANC", "right=NOV"), bty="n")


#Plot heritabilities

anc.h2 = list()
anc.h2[[1]] = 0
anc.h2[[2]] = 0
nov.h2 = anc.h2
has.NOV = grep("NOV", data.groups[3,])
for(i in 1:length(has.NOV)){
  idx = has.NOV[i]
  anc.data = input.data[[(idx-1)]]
  nov.data = input.data[[idx]]
  anc.h2[[i]] = anc.data[,3]
  nov.h2[[i]] = nov.data[,3]
}

anc.h2_ = list()
nov.h2_ = list()

for(i in 1:length(has.NOV)){
  anc.h2_ = as.list(c(anc.h2_, anc.h2[[i]]))
  nov.h2_ = as.list(c(nov.h2_, nov.h2[[i]]))
}

ANC.h2 = list()
NOV.h2 = list()
for(i in 1:length(anc.h2_)){
  ANC.h2[i] = as.matrix(anc.h2_[[i]])
  NOV.h2[i] = as.matrix(nov.h2_[[i]])
}

anc.heritability = unlist(as.data.frame(t(as.matrix(ANC.h2))), use.names=FALSE)
nov.heritability = unlist(as.data.frame(t(as.matrix(NOV.h2))), use.names=FALSE)

ANC = 1
ANC = rep(ANC, times=length(anc.heritability))
ID = c(1:length(anc.heritability))
anc.heritability = data.frame(h2=anc.heritability, env=ANC, ID=ID)

NOV = 2
NOV = rep(NOV, times=length(nov.heritability))
ID = c(1:length(nov.heritability))
nov.heritability = data.frame(h2=nov.heritability, enc=NOV, ID=ID)


comb.h2 = data.frame(h2=c(anc.heritability[,1], nov.heritability[,1]), env=c(anc.heritability[,2], nov.heritability[,2]), ID=c(anc.heritability[,3], nov.heritability[,3]))

#y.lim = c(0.2,1.0)
stripchart(comb.h2$h2~comb.h2$env, pch=16, method="jitter", jitter=0.05, vertical=TRUE, main="Diff in h2", xlab="Environment (ANC , NOV)", ylab="h2"
           #, ylim=y.lim
)
IDs = factor(comb.h2$ID)
IDs = levels(IDs)
for(i in 1:length(IDs)){
  variance=list(comb.h2$h2[i],comb.h2$h2[i+length(IDs)])
  variance = as.numeric(variance)
  env=list(1,2)
  env=as.numeric(env)
  abline(lm(variance~env), col="grey60")
}



#Vector projection

anc.project = list()
anc.project[[1]] = 0
anc.project[[2]] = 0
nov.project = list()
nov.project[[1]] = 0
nov.project[[2]] = 0
#has.NOV already exists from comparison of C.matrices Gmax values
has.NOV = grep("NOV", xstd.names)
for(i in 1:length(has.NOV)){
  idx = has.NOV[i]
  pops = xstd.names[(idx-1):idx]
  anc.idx = grep(pops[1], xstd.names)
  nov.idx = grep(pops[2], xstd.names)
  anc.mat = X.matrices[[anc.idx]]
  nov.mat = X.matrices[[nov.idx]]
  
  anc.egn = eigen(anc.mat)
  anc.bta = anc.egn$vectors[,1]
  anc.project[[i]] = t(anc.bta) %*% anc.mat %*% anc.bta
  
  nov.egn = eigen(nov.mat)
  nov.bta = nov.egn$vectors[,1]
  nov.project[[i]] = t(nov.bta) %*% nov.mat %*% nov.bta
}


ANC = 1
ANC = rep(ANC, times=length(anc.project))
ID = c(1:length(anc.project))
anc.project = as.data.frame(t(as.data.frame(anc.project)), row.names=c(1:length(anc.project)))
anc.project = data.frame(project=anc.project, env=ANC, ID=ID)

NOV = 2
NOV = rep(NOV, times=length(nov.project))
ID = c(1:length(nov.project))
nov.project = as.data.frame(t(as.data.frame(nov.project)), row.names=c(1:length(nov.project)))
nov.project = data.frame(project=nov.project, enc=NOV, ID=ID)


comb.project = data.frame(project=c(anc.project[,1], nov.project[,1]), env=c(anc.project[,2], nov.project[,2]), ID=c(anc.project[,3], nov.project[,3]))

#y.lim = c(0.2,1.0)
stripchart(comb.project$project~comb.project$env, method="jitter", jitter=0.0075, vertical=TRUE, main="Vector projection", xlab="Environment (ANC , NOV)", ylab="b'Gb"
           #, ylim=y.lim
)
IDs = factor(comb.project$ID)
IDs = levels(IDs)
for(i in 1:length(IDs)){
  variance=list(comb.project$project[i],comb.project$project[i+length(IDs)])
  variance = as.numeric(variance)
  env=list(1,2)
  env=as.numeric(env)
  abline(lm(variance~env))
}
