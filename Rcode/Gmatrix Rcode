#Downloads and unzips the G-matrix Data repository from GitHub
download.file("https://github.com/jprice96/G-matrix-Database/archive/master.zip", destfile="cov_matrices.zip")
unzip("cov_matrices.zip")

#Resets working directory from My Documents to downloaded Cov_matrices folder
setwd("G-matrix-Database-master/Cov_matrices")

#This creates a list of all of the files in the directory
data.files = dir(pattern="*csv")

#This is the number of files/matrices we have
num.of.files = length(data.files)

#This creates a blank list
input.data = list()

#This creates a list of file names minus the .csv
file.names = list()
for(i in 1:num.of.files){
  file.names[i] = gsub(".csv", "", data.files[i])
}
col.names = list("trait", "trait.mean", "var(P)")

#This is a loop which goes through the files and converts the data
for(i in 1:num.of.files){
  input.data[[i]] = read.csv(data.files[i], header=FALSE)
  colnames(input.data[[i]]) = col.names
}

#This names all of the files by their author, year and pop
names(input.data) = file.names

#Sorting by sub-pop
populations = list()
for (i in 1:length(file.names)){
  populations[i] = strsplit(as.character(file.names[i]), split="_")
}

data.groups = data.frame()
data.groups[1,1] = 0
n = 1
for (i in 1:length(populations)){
  new.pop = TRUE
  for (j in 1:length(data.groups[1,])){
    if (data.groups[1,j] == populations[[i]][1]){
      new.pop = FALSE
    }
  }
  if (new.pop == TRUE){
    pop.name = objects(input.data, pattern=as.character(populations[[i]][1]));
    data.groups[1,n] = populations[[i]][1];
    data.groups[2:(length(pop.name)+1),n] = pop.name;
    n = n + 1
  }
}

#Extracting just the G-matrices
G.matrices = list()
for (i in 1:num.of.files){
  G.matrices[[i]] = (input.data[[i]][,4:((4+nrow(input.data[[i]][1]))-1)])
}
names(G.matrices) = file.names

#Analysis of matrix size
size.comp = list()
size.comp[[1]] = 0
size.comp[[2]] = 0
anc.nov = c("ANC", "NOV")
Gmat = list()
attach(G.matrices)
for (i in 1:2){
  Gmat.sort = objects(G.matrices, pattern=as.character(anc.nov[i]))
  for (j in 1:length(Gmat.sort)){
    Gmat = get(Gmat.sort[j])
    Eign.Gmat = eigen(Gmat)
    eign.Gmat = Eign.Gmat$values
    size.comp[[i]][j] = sum(eign.Gmat)
  }
}
detach(G.matrices)


#Create boxplot of size comparison
boxplot(size.comp, names=anc.nov)
title(main="Size_comparison", ylab="Matrix size")


#Analysis of variance distribution
anc.vectors = list()
anc.vectors[1:2] = 0
nov.vectors = list()
nov.vectors[1:2] = 0

Gmat = list()
attach(G.matrices)
for (i in 1:2){
  Gmat.sort = objects(G.matrices, pattern=as.character(anc.nov[i]))
  for (j in 1:length(Gmat.sort)){
    Gmat = get(Gmat.sort[j])
    Eign.Gmat = eigen(Gmat)
    eign.Gmat = Eign.Gmat$values
    sumvalues = sum(eign.Gmat)
    if(i==1){
      for (k in 1:2){ #The 2 here limits to two eigen vectors being used
        anc.vectors[[k]][j] = eign.Gmat[k]/sumvalues
      }
    }
    if(i==2){
      for (k in 1:2){ #The 2 here limits to two eigen vectors being used
        nov.vectors[[k]][j] = eign.Gmat[k]/sumvalues
      }
    }
  }
}
detach(G.matrices)

#Create boxplot of vector comparison
boxplot(x=c(anc.vectors, nov.vectors), names=c("E1 ANC", "E1 NOV", "E2 ANC", "E2 NOV"))
title(main="Distribution of variance", xlab="Eigenvectors", ylab="Va / Vtotal")



# Vector projection
anc.vectors = list()
anc.vectors[1:2] = 0
nov.vectors = list()
nov.vectors[1:2] = 0

attach(G.matrices)
for(i in 1:length(data.groups[1,])){
  mat.ANC = get(data.groups[2,i])
  mat.NOV = get(data.groups[3,i])
  eig.ANC = eigen(mat.ANC)
  val.ANC = eig.ANC$values
  vec.ANC = eig.ANC$vectors
  project = mat.NOV*vec.ANC
  eig.NOV = eigen(project)
  val.NOV = eig.NOV$values
  for(j in 1:length(val.ANC)){
    anc.vectors[[j]][i] = val.ANC[j]
    nov.vectors[[j]][i] = val.NOV[j]
  }
}
detach(G.matrices)

#Create boxplot of vector projection
boxplot(x=c(anc.vectors, nov.vectors), names=c("E1 ANC", "E1 NOV", "E2 ANC", "E2 NOV"))
title(main="Projection of ANC vectors into NOV G", xlab="Eigenvectors", ylab="Va / Vtotal")
